<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  <title>Object script - Pikifen manual</title>
  <meta name="description" content="The Pikifen user manual">
  
  <link rel="stylesheet" href="../data/style.css">
  <script src="../data/script.js"></script>
</head>

<body onload="make_toc();">
  <iframe id="header-frame" src="header.html"></iframe>
  
  <div id="content">
    
    <h1>Object script</h1>
    
    <p>This page will explain how object scripts work in <i>Pikifen</i>, and how you can make your own. If you're in a hurry, feel free to read just the lines in bold, and even skip to the section you need. Otherwise, read every step in the tutorial and follow along! Feel also free to copy and paste an existing enemy's scripts and properties and adjust them to your liking, instead of creating everything from scratch.</p>

    <h2 id="intro">Introduction</h2>
    
    <h3 id="concepts">Key concepts</h3>
    
    <dl>
      <dt><b>Scripts tell an object what to do, and when.</b></dt>
      <dd>Scripts are how you tell an object, like an enemy, what it should do given different scenarios. Like "<i>When</i> a Pikmin shows up, <i>you move</i> to it. <i>When</i> the Pikmin is close, <i>you lunge</i> in for a bite." You can almost think of them like movie or theater scripts: "<i>When</i> the bad guy says 'I'll get you', <i>you say</i> 'never!'. <i>When</i> the bad guy throws the punch, <i>you dodge</i> to the side."</dd>
      <dt><b>An action is an instruction you want the object to do.</b></dt>
      <dd>In <i>Pikifen</i>, an object can perform a wide variety of actions, like moving somewhere, focusing its sights on another object, changing its animation, etc.</dd>
      <dt><b>An event refers to the moment something in the game happens, and you will want the object to perform actions.</b></dt>
      <dd>Events are the "when"s in the analogy above. An event can be something like when a Pikmin approaches, when the object reaches its intended destination, when its current animation finishes, etc. So, in essence when an <i>event</i> happens, the object will perform some <i>actions</i>.</dd>
      <dt><b>Objects can be in one of several states. Depending on the state, the same event can perform different actions.</b></dt>
      <dd>You can think of a state like a state of mind: tired, hungry, bored, etc. For object like enemies it's more along the lines of returning home, chasing prey, looking around, etc. States are important, because depending on the state, we may want the same event to trigger different actions. For instance, suppose a Pikmin comes near. What is a Red Bulborb to do? Well, it depends on its state: if it's sleeping, it must wake up, but if it is awake, it should lunge in for a chomp. Events and actions must take place inside of a state.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>"Mob" (short for "mobile object") is an alternate name for "object".</li>
      </ul></dd>
    </dl>

    <h2 id="guide">Guide</h2>
    
    <h3 id="creating">Creating the script</h3>
    
    <p>For this tutorial, we'll be writing the script for a Red Bulborb with some tweaks. If you haven't already, follow the <a href="object_type.html">object type tutorial</a> to create this new enemy.</p>
    
    <dl>
      <dt><b>Start by creating <code>Script.txt</code> in the object's data folder.</b></dt>
      <dd>Go to the folder where the object's data is, and create a new <a href="text_file.html">text file</a> called <code>Script.txt</code>.</dd>
      <dt><b>Inside, write a block called <code>script</code>.</b></dt>
      <dd>Inside the text file, write a line with <code>script {</code>. As explained <a href="text_file.html">here</a>, this is the start of a block. The next line should just be <code>}</code>, and now any line between these two is data inside the <code>script</code> block &ndash; the Red Bulborb's script in our case.</dd>
    </dl>

    <h3 id="state">Making a state</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        
    }
}
</pre>
    </div>
    
    <p>We'll need to start the script with a state. Let's think of the most "normal" state for a Bulborb, to serve as a starting point. That would probably be the sleeping state, right? Most Bulborbs we see in the games are asleep when first met, so it makes sense to start here.</p>
    
    <dl>
      <dt><b>Every block inside of the <code>script</code> block is a state.</b></dt>
      <dd>Let's start by creating a block called <code>sleeping</code> inside of the <code>script</code> block. Inside this block is where we'll specify what events and actions can take place while in this state.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>State names cannot have spaces in them.</li>
      </ul></dd>
    </dl>

    <h3 id="event">Looking out for an event</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        on_touch_opponent {
            
        }
    }
}
</pre>
    </div>

    <p>Now let's see, in this state, there's not much the Bulborb can do except wake up. Let's make it so that it wakes up when a Pikmin or leader touches it.</p>
    
    <dl>
      <dt><b>There is a specific list of available events, and they all start with <code>on_</code>.</b></dt>
      <dd>The events are moments in time where specific things happen, specific things that the engine recognizes. Their names all start with <code>on_</code>, as in "<i>on</i> the event that <i>this</i> happens, do <i>that</i>". The full list can be found <a href="#event-list">here</a>.</dd>
      <dt><b>Some events are related to "opponents" &ndash; these are objects that our object can hunt down.</b></dt>
      <dd>For an enemy, Pikmin and leaders are considered "opponents". This means that the event "when an opponent touches" will be triggered every time a Pikmin or a leader touches our Bulborb. Depending on the object's data, different types of objects can or cannot be considered "opponents".</dd>
      <dt><b>Each block inside a state's block represents an event.</b></dt>
      <dd>To add the "when an opponent touches" event, write a block called <code>on_touch_opponent</code>. Inside is where we'll write what actions the Bulborb should take.</dd>
    </dl>

    <h3 id="action">Performing an action</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        on_touch_opponent {
            set_animation waking_up
            set_state waking_up
        }
    }
    
    waking_up {
        
    }
}
</pre>
    </div>

    <p>Let's assume that you already have animations for the Bulborb &ndash; these include waking up, walking, biting, going back to sleep, etc. What we want now is for the Bulborb to wake up. Visually, we want its animation to change from the one where it is sleeping to the one where it wakes up and gets on its feet.</p>
    
    <dl>
      <dt><b>Like events, there is a specific list of available actions.</b></dt>
      <dd>Actions are what our object can do, and these too are specific things that the engine is capable of making an object do. The full list can be found <a href="#action-list">here</a>.</dd>
      <dt><b>Inside the event's block, write one action per line.</b></dt>
      <dd>We can run multiple actions in a row in an event, and each action should be written in its own line inside the event block. To set the Bulborb's animation to waking up, begin by writing <code>set_animation</code>.</dd>
      <dt><b>Most actions take arguments. These come after the action name and are separated by spaces.</b></dt>
      <dd>The <code>set_animation</code> action needs to know what animation to switch to, so write a space after <code>set_animation</code>, and then <code>waking_up</code>. In the Red Bulborb's animations, this is the name of the animation that makes it become awake and stand up, but when making your own objects, you can use whatever names you wish.</dd>
      <dt><b>Changing states in key in order to organize what events you want to handle.</b></dt>
      <dd>So, when the Bulborb is in the sleeping <i>state</i>, in the <i>event</i> that an opponent touches it, it will perform an <i>action</i> in which it changes its animation to waking up. Makes sense, but...when a Pikmin touches it, the Bulborb will visually change to an animation where it wakes up, and then what? Well, right after the Bulborb begins this animation, the engine will realize the next frame that an opponent is touching it (yet still). And because the Red Bulborb is still in the "sleeping" state, which is a state that is looking out for the "opponent is touching" event...it will just trigger the event again and again, which will keep restarting the animation (until the Pikmin walks away at least). The logical solution would be to change its state right after setting its animation, so that it may wake up in peace, without being interrupted by the constant "opponent is touching" events. As such, add a new action: <code>set_state waking_up</code>. As you can guess, this will make the Red Bulborb change to a <code>waking_up</code> state after starting the wake up animation. Might as well add the new state too; add an empty line between them to help with readability.</dd>
    </dl>
    
    <h3 id="on-enter">On enter</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        on_enter {
            set_animation sleeping
        }
        on_touch_opponent {
            set_state waking_up
        }
    }
    
    waking_up {
        on_enter {
            set_animation waking_up
        }
    }
}
</pre>
    </div>

    <dl>
      <dt><b>If you're running actions before changing a state, consider running those actions inside the state's <code>on_enter</code> event.</b></dt>
      <dd>When we set its animation to waking up, we're also set its state to "waking_up". Imagine we wanted the Bulborb to wake up for a reason other than an opponent touching it, like due to a timer or a nearby loud sound. It would be a pain to write an action to change animations alongside the action to change states. So instead, create an event in the "waking_up" state called <code>on_enter</code> and change the animation there &ndash; this event is run every time the state is entered, so no matter what made it go to the "waking_up" state, its animation will always be set appropriately!</dd>
      <dt><b>It's a good idea in general to use <code>on_enter</code> in order to let states be responsible for the actions related to them.</b></dt>
      <dd>Your script becomes much easier to understand if the reader can understand that "every time the Bulborb is waking up, its animation will always change accordingly". Plus, it's less repeated text anyway. There is also something to note with the Red Bulborb right now: it actually has no starting animation! The script has to tell it what animation to change to when it spawns. Since we want it to spawn in the "sleeping" state, and since every time the sleeping state is entered, the creature is meant to visually fall asleep, it makes sense to change its animation to "sleeping" in the "sleeping" state's <code>on_enter</code> event.</dd>
    </dl>
    
    <h3 id="on-anim-end">On animation end</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    waking_up {
        on_enter {
            set_animation waking_up
        }
        on_animation_end {
            set_state examining
        }
    }
}
</pre>
    </div>

    <p>Ok, now that the Red Bulborb can enter the "waking up" animation, what should it do while in it? Well, it shouldn't really be willing to fight, should it? It <i>is</i> still getting up, so it's not ready for that. In fact, it should do anything while in this state except finish getting up. As soon as it finishes though, it should probably look around for whatever woke it up.</p>
    
    <dl>
      <dt><b><code>on_animation_end</code> is a powerful tool for pacing.</b></dt>
      <dd>If you want the object to perform an action when it <i>finishes</i> doing something, and that something is behind an animation, just use the <code>on_animation_end</code> event. The alternative would be to wait for a set amount of time, but that's harder to do, and requires you to update the timer if you change the animation's length. As for what actions to get our Red Bulborb to perform, it would make sense to enter a state where it analyzes its surroundings and acts according to what it decides at the time (going back to sleep, chasing prey, etc.).</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>Because animations loop, this event gets triggered every time the final frame is finished (which is also when the animation returns to the loop frame).</li>
      </ul></dd>
    </dl>

    <h3 id="moving">Moving</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    examining {
        on_enter {
            set_animation examining
        }
        on_animation_end {
            set_state returning
        }
    }
    
    returning {
        on_enter {
            move_to_target home
        }
        on_reach_destination {
            set_state sleeping
        }
    }
}
</pre>
    </div>

    <p>In the "examining" state, we can set its animation to make it look around left and right in search of what prey to catch. Later on, we'll make it detect Pikmin nearby, but for now, if nothing catches its interest by the time it finishes its animation, it should head back home (the spawn point) and fall asleep. You might find it weird why the Bulborb would try to go home right after waking up, but remember that we can use the "examining" state elsewhere too, like after it finished eating all Pikmin, or has wandered too far.</p>
    
    <dl>
      <dt><b><code>move_to_target</code> tells an object to <i>start</i> moving towards a specific target.</b></dt>
      <dd>As soon as the <code>move_to_target</code> action is run, the object will start moving to where you specify, and will keep moving over time from there on, until it is told to stop or move elsewhere.</dd>
      <dt><b><code>move_to_target</code> takes a specific target as an argument, and other actions allow other types of movement.</b></dt>
      <dd>In order for the engine to know where to make the object move to, you have to write it as an argument for the action. Since we want the Red Bulborb to head home, write <code>home</code> as the argument &ndash; the engine recognizes this as a special word that means it should head towards the spawn coordinates.</dd>
      <dt><b>When it reaches its destination, <code>on_reach_destination</code> is triggered.</b></dt>
      <dd>For our Red Bulborb, when it reaches its destination &ndash; home &ndash; we can make it enter the state where it falls asleep.</dd>
    </dl>

    <h3 id="reach">Reach and chasing</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    examining {
        on_enter {
            set_animation examining
            set_near_reach search
            set_far_reach chase
        }
        on_opponent_in_reach {
            focus trigger
            set_state chasing
        }
        on_animation_end {
            set_state returning
        }
    }
    <span class="code-faded">(...)</span>
    chasing {
        on_enter {
            move_to_target focused_mob
        }
        on_focus_off_reach {
            set_state examining
        }
    }
}
</pre>
    </div>

    <p>What about moving towards a Pikmin? In the examining state, in the event that it spots a Pikmin, it should move towards it to try to eat it, right? But let's think about what it means to "spot a Pikmin".</p>
    
    <dl>
      <dt><b>An object considers another object to be "near" if it is within a certain reach.</b></dt>
      <dd>We want our Red Bulborb to detect Pikmin that it can reasonably see. If a Pikmin is within vision reach of the Bulborb, then the <code>on_opponent_in_reach</code> event will be triggered.</dd>
      <dt><b>Objects can have several "reaches", and different objectives require using different reaches.</b></dt>
      <dd>To notice a Pikmin, we can use a reach that's a good distance away, since the bug-eyed Bulborb can see fairly far. However, if the creature is giving chase, then the concept of "near" for the purposes of eating a Pikmin changes &ndash; it's no longer about the reach of its eyesight, but the reach of its lunge attack. At any moment in the script, you can swap out what constitutes as "near" using the <code>set_near_reach</code> action. When the Bulborb starts examining, i.e., when the "examining" state is entered, we want "near" to be considered its searching reach. So, type <code>set_near_reach search</code> as the action. We'll define this "search" reach's information <a href="#script-props">later on in the tutorial</a>.</dd>
      <dt><b>An object can be focused onto another object, until told otherwise.</b></dt>
      <dd>When the Red Bulborb notices its prey, i.e., when <code>on_opponent_in_reach</code> is triggered, we want the Bulborb to start moving towards the Pikmin. But the Pikmin will surely change position over time, so we can't just tell the Bulborb to move to the coordinates where the Pikmin is at the moment. In order to keep track of the enemy over time, we need to say that the Bulborb will take focus on the Pikmin. Then we can just order the Bulborb to chase after its focused object, and it will be able to keep up with the Pikmin as it moves.</dd>
      <dt><b>To choose what to focus on, the <code>focus</code> action can take an argument. <code>trigger</code> means it will focus on whatever triggered the event.</b></dt>
      <dd>How do we specify that we want the Bulborb to focus on the Pikmin that is near? Well, since when an opponent is near, the <code>on_opponent_in_reach</code> gets triggered, we can just tell the engine to focus on whatever object triggered the event. Add the action <code>focus trigger</code> to the <code>on_opponent_in_reach</code> event to do just that. This will make the Bulborb focus on the Pikmin in question.</dd>
      <dt><b>Use <code>move_to_target focused_mob</code> to get an object to constantly move towards its focus.</b></dt>
      <dd>After it focuses on the opponent found, it should change to a state where it's giving chase. In this state, add an action to move after said opponent: <code>move_to_target focused_mob</code>.</dd>
      <dt><b>Use reaches to detect if the focused object is "out of reach", with the action <code>set_far_reach</code> and event <code>on_focus_off_reach</code>.</b></dt>
      <dd>We will want the Bulborb's vision limit to allow it to lose track of its prey as well. When you set the "near" reach, you should also set the "far" reach, using the action <code>set_far_reach chase</code>; "chase" is another reach we'll define later. When the focused object is out of reach, the <code>on_focus_off_reach</code> event is triggered. This helpfully also gets triggered if the Pikmin becomes unavailable, like if it dies. So, let's add an action to return to the examining state in this event.</dd>
    </dl>

    <h3 id="attacking">Attacking</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    chasing {
        on_enter {
            move_to_target focused_mob
            set_near_reach attack
        }
        on_opponent_in_reach {
            set_state attacking
        }
        on_focus_off_reach {
            set_state examining
        }
    }
    
    attacking {
        on_enter {
            set_animation attacking
            start_chomping 3 mouth
        }
        on_animation_end {
            stop_chomping
            set_state eating
        }
    }
    
    eating {
        on_enter {
            set_animation eating
        }
        on_animation_end {
            swallow_all
        }
    }
}
</pre>
    </div>

    <p>In the "chasing" state, our Bulborb is in pursuit. It's got its sights locked on to the Pikmin, and is always moving in its direction. On the event that it gets near (remember to update the "reach"!), it should go for a bite.</p>
    
    <dl>
      <dt><b>Biting works by having the enemy's "mouth" capable of capturing Pikmin. This mouth is usually located wherever the "mouth" body part is.</b></dt>
      <dd>The general way biting works in the <i>Pikmin</i> games is that an enemy clamps its jaws in front of it, and any Pikmin that get hit will be caught in its mouth. In order for the whole "catching" part to work, we need to keep in mind something about animations; read the <a href="animation.html">animation tutorial</a> if you need a reminder. Each object has a set of body parts, and they are named. Enemies like a Red Bulborb should have a "mouth" body part, because this is the body part that will be keeping hold of any captured Pikmin. Though "mouth" is the standard, you can have any body parts in charge of chomping, like a tongue, or several proboscises.</dd>
      <dt><b>A body part can start chomping with the <code>start_chomping</code> action.</b></dt>
      <dd>When the Bulborb begins lunging, its mouth is no longer a passive body part sitting around doing nothing. The creature will open its mouth and will use it to capture Pikmin. So, in the beginning of its lunging procedure (i.e. when the Bulborb enters the "lunging" state), we should let the engine know that its "mouth" body part is now a Pikmin-eating body part by using the <code>start_chomping</code> action.</dd>
      <dt><b><code>start_chomping</code> takes the maximum capture limit and hitbox list as parameters.</b></dt>
      <dd>In the <i>Pikmin</i> games, if a bunch of Pikmin get hit by a Red Bulborb's bite, only 3 or 5 (depends on the game) will actually get caught. You can specify such a limit in the engine too. For our cases, let's go with <code>start_chomping 3 mouth</code>. In this action, <code>mouth</code> is the name of the body part that will be responsible for capturing Pikmin from here on, but if we had more, we could've added them afterwards, one per word.</dd>
      <dt><b>Remember to stop the chomping process at some point!</b></dt>
      <dd>When the lunge animation is over, you should set the "mouth" body part back to normal, so Pikmin don't accidentally get caught later when the enemy is, for instance, walking. To do this, write <code>stop_chomping</code>.</dd>
      <dt><b>An enemy can swallow the captured Pikmin with <code>swallow_all</code></b></dt>
      <dd>For our Red Bulborb, after the animation is over, we want it to enter a "chewing" state, and when that's finished, swallow all captured Pikmin. This is achieved with the action <code>swallow_all</code>. Other actions exist to swallow only some, or to release them all.</dd>
    </dl>

    <h3 id="vars">Variables</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
init {
    set_var pim 0
}

script {
    <span class="code-faded">(...)</span>
    attacking {
        on_enter {
            set_animation attacking
            start_chomping 3 mouth
        }
        on_animation_end {
            stop_chomping
            get_info pim chomped_pikmin
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
    </div>

    <p>The Red Bulborb lunges. But did it capture any Pikmin? We actually need to know this in order to decide if the creature should start chomping, or if it should flop to the ground.</p>
    
    <dl>
      <dt><b>You can ask the engine for information using the <code>get_info</code> action.</b></dt>
      <dd>When the attack animation ends, we want to know how many Pikmin the Red Bulborb has chomped, so let's ask with <code>get_info pim chomped_pikmin</code>. Here, <code>chomped_pikmin</code> is a special word that means we want to know, well, how many Pikmin are chomped.</dd>
      <dt><b>Information, like the answer to the <code>get_info</code> questions, is saved in a variable.</b></dt>
      <dd>In the action you wrote, <code>pim</code> is the name of a variable (or "var"). This is some place in the object's memory that will hold information for us. Its name can be whatever, but in this tutorial, let's go with "pim", which is short for "Pikmin in mouth". After that action is run, the number of Pikmin chomped will reside inside the "pim" variable in the object's memory, from here on. You can have as many variables as you want.</dd>
      <dt><b>The value inside of a variable can be accessed in an action by writing the variable's name after a dollar sign.</b></dt>
      <dd>After the "pim" variable received a value, we can get that value and make use of it in the script, simply by typing <code>$pim</code>. When the script is run, it will replace that <code>$pim</code> with 0, or 1, or whatever else the "pim" variable is worth at the time.</dd>
      <dt><b>It's good practice to declare a starting value for your variables.</b></dt>
      <dd>For this, you can create an <code>init</code> block <i>outside</i> of the <code>script</code> block, and in it, add <code>set_var pim 0</code>. This will set the value of the "pim" variable to 0. Any actions inside this block will be run when the object is created, so you always know what the starting value of every variable is.</dd>
      <dt><b>Specific objects can also spawn with specific values in specific variables. Use this to allow different objects in the area to act differently.</b></dt>
      <dd>Any specific object in the area can spawn with some new variables set, or some initial variables altered from the norm. For instance, an Armored Cannon Beetle can spawn a boulder and tell it to be homing, or in the area editor, you can tell one specific Pellet Posy to start already bloomed. This data is stored in the script variables, and parts of the script can make use of them to change the object's behavior. Or if a given variable is not set, the script can use the default value specified in the aforementioned <code>init</code> block. You can use this to allow different objects to behave differently using the same script.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>The engine can make use of the script variable system to allow you to set some internal data about the object, like a Pikmin's starting maturity, or an object's team. You don't need to do anything with this information, but it is helpful to know this is how the engine works.</li>
      </ul></dd>
    </dl>

    <h3 id="conditions">Conditions</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
<span class="code-faded">(...)</span>
script {
    <span class="code-faded">(...)</span>
    attacking {
        on_enter {
            set_animation attacking
            start_chomping 3 mouth
        }
        on_animation_end {
            stop_chomping
            get_info pim chomped_pikmin
            if $pim > 0
                set_state eating
            else
                set_state flopping
            end_if
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
    </div>

    <p>Now to actually decide what to do after the lunge. The creature's behavior splits into two here: <i>if</i> it caught something, it should change to a chomping state, <i>else</i>, it should flop to the ground. This conditional logic can be written in the script.</p>
    
    <dl>
      <dt><b>You can choose what the next actions should be with an <code>if</code> action.</b></dt>
      <dd>After knowing how many Pikmin got bit, let's run an <code>if</code> action. Write it down as such: <code>if $pim > 0</code>. This action, when run, will check the number of Pikmin in its mouth, via our "pim" variable. Naturally, in this case, we want to check if more than zero Pikmin got caught. Then this action will change the flow of the script: if the Bulborb caught Pikmin, the script continues on to the next actions. So after this <code>if</code> action, add the action to enter a chewing state. Although in this case we're just checking if a number is larger than another, the <code>if</code> action can do other comparisons.</dd>
      <dt><b>If the condition is true, the script will run what comes next. Otherwise, it will jump to the matching <code>else</code> action.</b></dt>
      <dd>But what if the Bulborb didn't capture anything? Well, write an <code>else</code> action after the action that sets to the chewing state. And after that, write the action to change to a flopping state. With all of this logic combined, the engine will enter that <code>if</code> action, and if it realizes the condition is false (i.e. no Pikmin got chomped), it will jump to the actions after the "else".</dd>
      <dt><b>Finish your conditional logic with <code>end_if</code></b>.</dt>
      <dd>To wrap up the conditional part of this event, after the action that changes to the flopping state, you will need to add an <code>end_if</code> action. With this, the engine knows that what comes after is no longer a part of the conditional logic, and its flow works like normal.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>You don't always need to add an "else" part to your condition.</li>
        <li>You may want to indent (add another tab at the start) lines inside the "if" and "else" parts. This tutorial's logic is simple, but more complex conditions and flows will be much easier to read if you can easily tell what belongs to what part of the condition, just from the way the text is laid out.</li>
      </ul></dd>
    </dl>

    <h3 id="death">Death</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
death_state = dying
<span class="code-faded">(...)</span>
script {
    <span class="code-faded">(...)</span>
    dying {
        on_enter {
            start_dying
            set_animation dying
        }
        on_animation_end {
            finish_dying
        }
    }
}
</pre>
    </div>

    <dl>
      <dt><b>When an object reaches 0 health, the script automatically jumps to a death state.</b></dt>
      <dd>The enemy can die at (almost) any moment. When that happens, the engine automatically jumps the script into a different state, so you don't need to worry about listening to the death event on every single state.</dd>
      <dt><b>The name of this state is specified in the <code>death_state</code> property outside the script.</b></dt>
      <dd>To specify what state it should jump into, go out of the <code>script</code> block, and write a line with <code>death_state = dying</code>. This way, the engine knows that when the enemy's HP reaches 0, it must enter the "dying" state. Be sure to also write this new state.</dd>
      <dt><b>There are two usually parts to an enemy's death: the start and the end.</b></dt>
      <dd>When an enemy's HP reaches 0, you likely want to make them perform a fainting animation, as well as call a special action that will run some extra code related to an enemy beginning to die (this code will, amongst other things, create the sparkling particles). This is done with the action <code>start_dying</code>. When it's time to register the enemy as completely dead (like when the fainting animation ends), you need to call the action <code>finish_dying</code>. This will make the object carriable, release a spirit, etc.</dd>
    </dl>

    <h3 id="timers">Timers</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
<span class="code-faded">(...)</span>
script {
    sleeping {
        on_enter {
            set_animation sleeping
            set_timer 20
        }
        on_touch_opponent {
            set_state waking_up
        }
        on_timer {
            set_state waking_up
        }
    }
    
    waking_up {
        on_enter {
            set_animation waking_up
            set_timer 0
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
    </div>

    <p>Remember earlier when the idea of having the Bulborb wake up due to a biological timer came up? Let's implement that. Let's say that every time the Bulborb falls asleep, its biological clock sets an alarm for 20 seconds, at which point, it will wake up on its own, look around, and if there's nothing going on, fall asleep again.</p>
    
    <dl>
      <dt><b>Start the timer with <code>set_timer</code>.</b></dt>
      <dd>When the Bulborb falls asleep, so when the "sleeping" state is entered, use the following action: <code>set_timer 20</code>. This will start an internal timer for the object that will tick in 20 seconds.</dd>
      <dt><b>When the timer reaches 0, the <code>on_timer</code> event is triggered.</b></dt>
      <dd>In the sleeping state, look out for the <code>on_timer</code> event. This will be triggered when the timer reaches 0. This would be the time to change the state to the "waking_up" state.</dd>
      <dt><b>If the timer is running, <code>set_timer 0</code> will deactivate it.</b></dt>
      <dd>What if the Red Bulborb's sleep is interrupted by a leader or Pikmin walking near? The timer would keep going, which is something we likely don't want. You can kill the timer by simply typing <code>set_timer 0</code>.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>An object can only have one active timer at any moment.</li>
        <li>When a timer reaches 0, it deactivates, so if you have a timer that you want to tick every X seconds, you need to set the timer again when it reaches zero.</li>
      </ul></dd>
    </dl>
    
    <h3 id="script-props">Script-related properties</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
first_state = sleeping
<span class="code-faded">(...)</span>
script {
    <span class="code-faded">(...)</span>
    chasing {
        on_enter {
            move_to_target focused_mob
            set_near_reach attack
        }
        on_opponent_in_reach {
            set_state attacking
        }
        on_focus_off_reach {
            set_state examining
        }
        on_far_from_home {
            set_state returning
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
      <p>And the data file should look like:</p>
<pre>
<span class="code-faded">(...)</span>
itch_damage = 70
itch_time = 5
territory_radius = 500
reaches {
    wake_up = 10 360
    search = 250 180 30 360
    attack = 40 30
    chase = 250 360
}
</pre>
    </div>

    <p>In order for the engine to get a grip on this script, we'll need to specify a few more things. After this section, it's all up to you to finish the Red Bulborb however you like!</p>
    
    <dl>
      <dt><b>The <code>first_state</code> property specifies what the starting state is.</b></dt>
      <dd>Outside of the <code>script</code> block, add the following property outside the <code>script</code> block: <code>first_state = sleeping</code>.</dd>
      <dt><b>Use <code>itch_damage</code> and <code>itch_time</code> to control when an enemy should shake Pikmin off, along with the <code>on_itch</code> event.</b></dt>
      <dd>These two properties go in the enemy's <code>Data.txt</code> file. After an enemy has taken a certain amount of damage, it will be considered "itchy". With this, you can listen to the <code>on_itch</code> event, and make the enemy shake the Pikmin off. Handling this event automatically resets the amount of damage, making it possible for the enemy to be itchy again next time it takes this amount of damage. Setting this to something like 10% or 20% of the max health is usually the way to go. <code>itch_time</code> exists to stop the enemy from shaking too often. Specify a minimum time requirement between itches here, in seconds. 5 is probably good for our Bulborb.</dd>
      <dt><b>Use <code>territory_radius</code> to determine when to trigger <code>on_far_from_home</code>.</b></dt>
      <dd>When the enemy travels too far from its home, the <code>on_far_from_home</code> event is triggered. How far this is is controlled by the <code>territory_radius</code> property, also in <code>Data.txt</code>. You want to put around 500 here for the Red Bulborb.</dd>
      <dt><b>The <code>reaches</code> block in <code>Data.txt</code> contains information about each reach.</b></dt>
      <dd>Remember the reaches from before? This is where you'll define what a "waking up" reach is, what a "chasing" reach is, etc. In <code>Data.txt</code>, create a block called <code>reaches</code>. Inside, we'll write one reach per line.</dd>
      <dt><b>Each reach has a name, a distance, and an angle.</b></dt>
      <dd>Let's start with the <code>wake_up</code> reach, by typing <code>wake_up = 10 360</code>. The <code>10</code> there is the distance &ndash; any Pikmin or leader within 10 units of the Red Bulborb will be considered "in reach". The <code>360</code> is the angle, and because we want this to happen regardless of where the Pikmin is in relation to where the Bulborb is facing, it's a 360 degree range.</dd>
      <dt><b>A reach can also be made of two distance + angle pairs.</b></dt>
      <dd>Now, add <code>search = 250 180 30 360</code> for the next range. The first part means that Pikmin within 180 degrees of the Bulborb's front, and within 250 units, will be considered "in reach". This makes sense: any Pikmin that's within a fair distance in front of the Bulborb should be enough for the enemy to spot it. The second part means that any Pikmin within 30 units, at any angle, will <i>also</i> be considered "in reach". This extra part is useful for when the Pikmin is, for instance, hitting the Bulborb's back. Since the Pikmin is completely behind the Bulborb, it wouldn't be caught by the 250-180 part, since that one only finds Pikmin in front. This way, any Pikmin close enough will also be considered "seen" by the Bulborb. The reason why we don't set the within-250-unit reach to 360 degrees is because that would unrealistically make the Bulborb see Pikmin far away that are <i>behind it</i>. When making enemies yourself, don't be afraid to try some trial-and-error. The Bulborb's other reaches will be something like <code>attack = 40 30</code> (Pikmin within this reach should be chomped), and <code>chase = 250 360</code> (focused Pikmin outside this reach will be considered lost).</dd>
      <dt><b>Use <code>states_ignoring_death</code> to stop an object's scrip from being interrupted by a death.</b></dt>
      <dd>When the object's health reaches 0, the script jumps to a different state, as explained previously. In the <code>states_ignoring_death</code> property of <code>Script.txt</code>, you can list states that are meant to ignore the death event (separated by semicolon). If you find that a death event is being sent on states you don't want, add the state's name here. Similarly, there's a <code>states_ignoring_spray</code> property.</dd>
    </dl>
    
    <h2 id="hardcoded">Hardcoded script</h2>
    
    <dl>
      <dt><b>Some categories of object type do not require you to build a script.</b></dt>
      <dd>Pikmin, leaders, and some other categories all have a hardcoded script inside the engine's logic, and you can create a new Pikmin or leader without worrying about scripting them. This is because these objects require much more complex operations than normal.</dd>
      <dt><b>You cannot edit hardcoded scripts, but you can enhance them.</b></dt>
      <dd>To do so, add a <code>Script.txt</code> file to the object's folder like normal. Now you can write existing states or new ones, and inside, write existing events or new ones. If this is a new state, or a new event in an existing state, the engine will simply run the actions you specify when the time comes. Otherwise, the engine will run your actions first and then run whatever hardcoded actions it is meant to.</dd>
      <dt><b>If the state/event already exists, your actions are run first by default.</b></dt>
      <dd>The reason the engine runs your actions first is because its own logic likely changes the state, and any action that comes after a state change will be ignored. That said, if you want the actions in a given event to take place <i>after</i> the hardcoded actions, write <code>custom_actions_after</code> as the first line in your list of actions.</dd>
      <dt><b>The hardcoded scripts are written in the engine's code in C++, and have access to things the text file scripts do not.</b></dt>
      <dd>To know what states and events an object in a category uses, your best bet is to open the engine's source code, check the <code>.cpp</code> code files inside the <code>source/mob_fsms</code> folder, and try to make sense of them. Keep in mind some states handle events that cannot be recognized in a <code>Script.txt</code> file, so you will be unable to extend those.</dd>
      <dt><b>The logic behind the hardcoded scripts is really complex, so try not to get too creative!</b></dt>
      <dd>Because the engine expects objects to follow their hardcoded script, which usually involves a lot of complex tasks, tampering with the script is risky. For instance, if an object was meant to change to a specific state, and you make it change to another one instead, the engine could later on try to do something with the state it <i>thinks</i> the object should be at, and crash. As such, if you want to enhance a hardcoded script, try sticking to things like adding particles, setting some script variables, sending messages, etc.</dd>
    </dl>
    
    <h2 id="event-list">List of events</h2>
    
    <table>
      <tr><th>Event</th><th>Description</th></tr>
      <tr>
        <th style="text-align: left;"><code>on_enter</code></th>
        <td>Triggered when the current state is entered.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_leave</code></th>
        <td>Triggered when the current state is left.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_animation end</code></th>
        <td>Triggered when the current animation finishes. Technically, this is triggered when the current animation begins looping.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_damage</code></th>
        <td>Triggered when the object takes any sort of damage.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_far_from_home</code></th>
        <td>Triggered every frame the object is far enough away from its home (as per the <code>territory_radius</code> property).</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_focus_off_reach</code></th>
        <td>Triggered every frame the focused object is beyond the current "far reach", or is dead. Also triggered when the focused object is deleted. Useful for making enemies lose track of focused Pikmin that are too far away.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_frame_signal</code></th>
        <td>Triggered when one of the frames of the current animation has launched a signal. The number of the signal can be obtained with the <code>get_info</code> action.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_held</code></th>
        <td>Triggered when the object is picked up by another one. Particularly useful for tool objects.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_hitbox_touch_eat</code></th>
        <td>Triggered when one of the object's normal hitboxes touches an opponent's "eat" hitbox. Particularly useful for tool objects.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_hitbox_touch_a_n</code></th>
        <td>Triggered when one of the object's attack hitboxes touches an opponent's normal hitbox. The opposite doesn't exist since it's reserved by the engine for controlling attack damage.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_itch</code></th>
        <td>Triggered when the object takes a certain amount of damage after the last itch, as defined by the <code>itch_damage</code> property. It will also only trigger if it's been a certain amount of time since the last itch, as per <code>itch_time</code>. If the current state cannot handle this event, it will continue being sent until an event shows up that can handle it.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_land</code></th>
        <td>Triggered every frame the object is touching the floor.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_object_in_reach</code></th>
        <td>Triggered when an object has entered within its "near reach". Will trigger every frame for the same object, too.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_opponent_in_reach</code></th>
        <td>Same as <code>on_object_in_reach</code>, but for opponents only.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_pikmin_land</code></th>
        <td>Triggered when a thrown Pikmin lands on it. Might not work on objects that are too short.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_reach_destination</code></th>
        <td>Triggered every frame that the object is in its destination, by moving there with any of the "move" actions.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_receive_message</code></th>
        <td>Triggered when another object sent it a message. The contents of the message can be obtained with the <code>get_info</code> action.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_released</code></th>
        <td>Triggered when the object was being held by another, but has now been released. Particularly useful for tool objects.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_touch_hazard</code></th>
        <td>Triggered when it touches a hazard, whether from a hitbox, or from a sector.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_touch_object</code></th>
        <td>Triggered every frame it is touches an object, for every object it's touching.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_touch_opponent</code></th>
        <td>Same as <code>on_touch_object</code>, but for opponents only.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_tick</code></th>
        <td>Triggered every single game frame. Because a frame can last for any amount of time, this is not an appropriate way to make things change over time. It is more useful for when you want to constantly update something, like make the object constantly turn to its focused object's position.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_timer</code></th>
        <td>Triggered when the internal timer reaches 0.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_touch_wall</code></th>
        <td>Triggered every frame it is touching a wall.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_weight_added</code></th>
        <td>Triggered when an object starts standing atop this one, thus adding weight.</td>
      </tr>
      <tr>
        <th style="text-align: left;"><code>on_weight_removed</code></th>
        <td>Triggered when an object that was standing atop this one leaves, thus removing weight.</td>
      </tr>
    </table>
    
    <h2 id="action-list">List of actions</h2>
    
    <table>
      <tr><th>Action</th><th>Description</th></tr>
      <tr>
        <th><code>add_health</code></th>
        <td><dl>
          <dt><b><code>add_health &lt;amount&gt;</code></b></dt>
          <dd>Add &lt;amount&gt; health to the object's health. You can also remove some health by specifying a negative number.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>arachnorb_plan_logic</code></th>
        <td>
          Special logic for <a href="https://www.pikminwiki.com/Arachnorb_family">arachnorb</a>-type enemies. This is used to internally plan what sort of movements the arachnorb's feet will need to do for the next sequence of steps, so that it can achieve the specified goal. This only works on the object that represents the arachnorb's head, which must be a <a href="object_types.html#parent">parent object</a> with feet children objects. In order for the engine to know where to position the feet, the following script variables should be declared: <code>max_step_distance</code> specifies the maximum distance a foot can move per step; <code>max_turn_angle</code> specifies the maximum amount of degrees the arachnorb can turn per step; <code>min_turn_angle</code> specifies the minimum amount of degrees the arachnorb can turn per step; <code>feet_normal_distance</code> specifies the usual distance the feet are from the center of the head.
          <dl><dt><code><b>arachnorb_plan_logic</b> home</code></dt>
          <dd>Sets up the internal logic for the arachnorb to head home. This will automatically decide how to turn or how to walk forward to get there.</dd>
          <dt><code><b>arachnorb_plan_logic</b> forward</code></dt>
          <dd>Sets up the internal logic for the arachnorb to move forward.</dd>
          <dt><code><b>arachnorb_plan_logic</b> cw_turn</code></dt>
          <dd>Sets up the internal logic for the arachnorb to rotate clockwise. When this is called manually, the arachnorb turns a random angle between the minimum and maximum turn amounts.</dd>
          <dt><code><b>arachnorb_plan_logic</b> ccw_turn</code></dt>
          <dd>Same as the <code>cw_turn</code> goal, but for a counter-clockwise turn.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>calculate</code></th>
        <td><dl>
          <dt><code><b>calculate</b> &lt;variable&gt; &lt;left&gt; &lt;operator&gt; &lt;right&gt;</code></dt>
          <dd>Calculates the mathematical operation between the operands and sets the variable to the result. It makes sense to use a variable in at least one of the operands, otherwise you're just punching in a fixed number calculation that any household calculator could tell you about. The operator can be <code>+</code> (add), <code>-</code> (subtract), <code>*</code> (multiply), <code>/</code> (divide), or <code>%</code> (<a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a>). For instance, <code>calculate jumps $jumps + 1</code> would increment the number of jumps. Be careful not to get your $ signs confused &ndash; the &lt;variable&gt; field shouldn't use it!</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>delete</code></th>
        <td>Delete this object.</td>
      </tr>
      <tr>
        <th><code>drain_liquid</code></th>
        <td>Makes the liquid in the sector it is on start draining. After a few seconds, it will be completely liquid-free. This will affect the sector it is on as well as all neighboring sectors that have liquid, or are bridges (or bridge rails).</td>
      </tr>
      <tr>
        <th><code>else</code></th>
        <td>If the corresponding <code>if</code> action's check ends up being false, the script will run the actions after this <code>else</code>, until it reaches the matching <code>end_if</code>.</td>
      </tr>
      <tr>
        <th><code>end_if</code></th>
        <td>Closes a condition started by an <code>if</code> action.</td>
      </tr>
      <tr>
        <th><code>finish_dying</code></th>
        <td>Runs the procedure related to the end of the object's death sequence. Amongst other things, this makes enemies unleash a spirit.</td>
      </tr>
      <tr>
        <th><code>focus</code></th>
        <td><dl>
          <dt><code><b>focus</b> trigger</code></dt>
          <dd>Focuses on the object that triggered the event.</dd>
          <dt><code><b>focus</b> link</code></dt>
          <dd>Focuses on the first linked object, if any. You cannot use this when the mob has just spawned, since it doesn't have link information by that point.</dd>
          <dt><code><b>focus</b> parent</code></dt>
          <dd>Focuses on the parent object, if any. You cannot use this when the mob has just spawned, since it doesn't have parent information by that point.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>get_chomped</code></th>
        <td>Makes the object get chomped as if it were a Pikmin. This is only applicable if run inside the <code>on_hitbox_touch_eat</code> event.</td>
      </tr>
      <tr>
        <th><code>get_focus_var</code></th>
        <td><dl>
          <dt><code><b>get_focus_var</b> &lt;destination_variable&gt; &lt;variable_from_focus&gt;</code></dt>
          <dd>Sets the variable &lt;destination_variable&gt; of this mob to the same value as the variable &lt;variable_from_focus&gt; of the focused mob, if any.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>get_info</code></th>
        <td><dl>
          <dt><code><b>get_info</b> &lt;destination_variable&gt; &lt;information&gt;</code></dt>
          <dd>
            Sets the variable &lt;destination_variable&gt; to some special information. The possible data are:
            <ul>
              <li><code><b>body_part</b></code>: For events that deal with hitboxes, this is the name of this mob's body part that's responsible.</li>
              <li><code><b>chomped_pikmin</b></code>: How many Pikmin it currently has chomped.</li>
              <li><code><b>day_minutes</b></code>: What time of the in-game day it is, in minutes.</li>
              <li><code><b>field_pikmin</b></code>: How many Pikmin are currently on the field.</li>
              <li><code><b>frame_signal</b></code>: What the signal was that triggered an <code>on_frame_signal</code> event.</li>
              <li><code><b>health</b></code>: The object's current health.</li>
              <li><code><b>latched_pikmin</b></code>: How many Pikmin are currently latched on to it.</li>
              <li><code><b>latched_pikmin_weight</b></code>: Total weight of the Pikmin that are currently latched on to it.</li>
              <li><code><b>message</b></code>: What the message was that got sent when the <code>on_receive_message</code> event got triggered.</li>
              <li><code><b>message_sender</b></code>: Name of the type of object that sent the message, when an <code>on_receive_message</code> event gets triggered.</li>
              <li><code><b>mob_category</b></code>: Category of the mob that triggered the event. This is the same name as the corresponding folder in <code>Game_data/Types</code>. Only available for certain events.</li>
              <li><code><b>mob_type</b></code>: Type of the mob that triggered the event. This is the name defined in the <code>name</code> property of the object type's <code>Data.txt</code> file. Only available for certain events.</li>
              <li><code><b>other_body_part</b></code>: For events that deal with hitboxes, this is the name of the other mob's body part that's responsible.</li>
              <li><code><b>weight</b></code>: Current weight on top of it.</li>
            </ul>
          </dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>get_random_decimal</code></th>
        <td><dl>
          <dt><code><b>get_random_decimal</b> &lt;variable&gt; &lt;minimum_value&gt; &lt;maximum_value&gt;</code></dt>
          <dd>Places a random value between &lt;minimum_value&gt; and &lt;maximum_value&gt; (including) into the variable &lt;variable&gt;. This number is a real number, so it can have decimal places.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>get_random_int</code></th>
        <td><dl>
          <dt><code><b>get_random_int</b> &lt;variable&gt; &lt;minimum_value&gt; &lt;maximum_value&gt;</code></dt>
          <dd>Places a random value between &lt;minimum_value&gt; and &lt;maximum_value&gt; (including) into the variable &lt;variable&gt;. This number is an integer number, so it will not have decimal places.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>goto</code></th>
        <td><dl>
          <dt><code><b>goto</b> &lt;label_name&gt;</code></dt>
          <dd>Orders the script to jump to where the label named &lt;label_name&gt; is. The label must be in the same event block as this <code>goto</code>. You can use this to loop actions multiple times in a row by returning to the top of the loop.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>if</code></th>
        <td>
          Only executes the next actions, until an <code>else</code> or <code>end_if</code> action, if the condition you specify is true. If not, it jumps to the matching <code>else</code> or <code>end_if</code> action.
          <dl><dt><code><b>if</b> &lt;left&gt; &lt;operator&gt; &lt;right&gt;</code></dt>
          <dd>
            &lt;left&gt; and &lt;right&gt; are two values, and &lt;operator&gt; is how you want to compare them. As such, it makes sense to replace at least one of the values with a variable. Note that due to scripting limitations, only &lt;right&gt; may have spaces, if it is a string. The possible operators are:
            <ul>
              <li><code><b>=</b></code>: True if &lt;left&gt; matches &lt;right&gt;. It works with text too.</li>
              <li><code><b>!=</b></code>: True if they don't match; also works with text.</li>
              <li><code><b>&lt;</b></code>: True if the number in &lt;left&gt; is less than the number in &lt;right&gt;.</li>
              <li><code><b>&gt;</b></code>: Greater than.</li>
              <li><code><b>&lt;=</b></code>: Less than or equal.</li>
              <li><code><b>&gt;=</b></code>: Greater than or equal.</li>
            </ul>
          </dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>label</code></th>
        <td><dl>
          <dt><code><b>label</b> &lt;label_name&gt;</code></dt>
          <dd>Labels this point of the script as &lt;label_name&gt;. You can then use the <code>goto</code> action to force the script to go to this point at will. Each label is only accessible to the event block it belongs to.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>move_to_absolute</code></th>
        <td><dl>
          <dt><code><b>move_to_absolute</b> &lt;x&gt; &lt;y&gt;</code></dt>
          <dd>Tells the object to begin moving to the specified area coordinates.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>move_to_relative</code></th>
        <td><dl>
          <dt><code><b>move_to_relative</b> &lt;x&gt; &lt;y&gt;</code></dt>
          <dd>Tells the object to begin moving to the specified relative coordinates. See <a href="#rel-coord">here</a> for more info.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>move_to_target</code></th>
        <td><dl>
          <dt><code><b>move_to_target</b> &lt;target&gt;</code></dt>
          <dd>
            Tells the object to begin moving towards a special target. Possible values:
            <ul>
              <li><code>arachnorb_foot_logic</code>: Used by <a href="https://www.pikminwiki.com/Arachnorb_family">arachnorb</a> feet objects to move according to the internal plan. See the <code>arachnorb_plan_logic</code> action for more information.</li>
              <li><code>away_from_focused_mob</code>: Move away from the focused object, thus going in the direct opposite direction.</li>
              <li><code>focused_mob</code>: Move towards the focused object, following it as it moves.</li>
              <li><code>focused_mob_position</code>: Move towards the position of the focused object at this exact moment. In other words, don't follow it as it moves.</li>
              <li><code>home</code>: Move towards home (spawn point).</li>
              <li><code>linked_mob_average</code>: Move towards the average position of its linked objects. Useful for keeping an <a href="https://www.pikminwiki.com/Arachnorb_family">arachnorb</a>'s head in the center position of its feet objects, for instance.</li>
            </ul>
          </dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>order_release</code></th>
        <td>Orders the Pikmin that is holding on to this object to release it.</td>
      </tr>
      <tr>
        <th><code>print</code></th>
        <td><dl>
          <dt><code><b>print</b> &lt;text&gt;</code></dt>
          <dd>Prints some text to the top of the screen. Only useful for debugging the script, so you know how much a variable is worth, where the script passes, etc.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>receive_status</code></th>
        <td><dl>
          <dt><code><b>receive_status</b> &lt;status name&gt;</code></dt>
          <dd>Applies the specified status effect.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>release</code></th>
        <td>All captured Pikmin are safely freed.</td>
      </tr>
      <tr>
        <th><code>remove_status</code></th>
        <td><dl>
          <dt><code><b>remove_status</b> &lt;status name&gt;</code></dt>
          <dd>Removes the specified status effect, if the object is currently afflicted by it.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>send_message_to_focus</code></th>
        <td><dl>
          <dt><code><b>send_message_to_focus</b> &lt;message&gt;</code></dt>
          <dd>Send a text message to the currently focused mob. Objects that receive a message will be thrown the <code>on_receive_message</code> event.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>send_message_to_links</code></th>
        <td><dl>
          <dt><code><b>send_message_to_links</b> &lt;message&gt;</code></dt>
          <dd>Same as <code>send_message_to_focus</code>, but it sends it to all linked objects.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>send_message_to_nearby</code></th>
        <td><dl>
          <dt><code><b>send_message_to_nearby</b> &lt;distance&gt; &lt;message&gt;</code></dt>
          <dd>Same as <code>send_message_to_focus</code>, but it sends it to all objects that are within the specified distance.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_animation</code></th>
        <td><dl>
          <dt><code><b>set_animation</b> &lt;animation&gt;</code></dt>
          <dd>Changes to and begins the animation &lt;animation&gt;.</dd>
          <dt><code><b>set_animation</b> &lt;animation&gt; no_restart</code></dt>
          <dd>Same as above, but doesn't set the frame number to 0, meaning that animation will continue from whatever frame number the previous one left off.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_far_reach</code></th>
        <td><dl>
          <dt><code><b>set_far_reach</b> &lt;reach_name&gt;</code></dt>
          <dd>Makes it use the specified reach as the "far reach", from here on out.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_gravity</code></th>
        <td><dl>
          <dt><code><b>set_gravity</b> &lt;multiplier&gt;</code></dt>
          <dd>Sets how gravity affects this object. 1 is normal, 0 is no gravity, 0.5 is half gravity, -1 is upwards gravity, etc.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_health</code></th>
        <td><dl>
          <dt><code><b>set_health</b> &lt;amount&gt;</code></dt>
          <dd>Sets the object's health to the specified number.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_height</code></th>
        <td><dl>
          <dt><code><b>set_height</b> &lt;height&gt;</code></dt>
          <dd>Sets the object's height. Objects atop this one will rise or lower accordingly.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_hiding</code></th>
        <td><dl>
          <dt><code><b>set_hiding</b> &lt;true/false&gt;</code></dt>
          <dd>Sets whether or not the engine should hide this object's shadow and health from here on out. This is useful, for instance, when a Sheargrub digs underground.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_holdable</code></th>
        <td><dl>
          <dt><code><b>set_holdable</b></code></dt>
          <dd>Makes it so that nothing can hold this object.</dd>
          <dt><code><b>set_holdable</b> &lt;rules&gt;</code></dt>
          <dd>Makes it so that the specified kinds of objects can hold this object. You can write more than one, by writing one in each word. The valid values are <code>pikmin</code> for Pikmin, and <code>enemies</code> for enemies.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_huntable</code></th>
        <td><dl>
          <dt><code><b>set_huntable</b> &lt;true/false&gt;</code></dt>
          <dd>Sets whether or not this object can currently be hunted by other objects. This does not affect whether or not other objects can hurt it.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_limb_animation</code></th>
        <td><dl>
          <dt><code><b>set_limb_animation</b> &lt;animation&gt;</code></dt>
          <dd>Same as <code>set_animation</code>, but for the limb connecting it to its parent mob.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_near_reach</code></th>
        <td><dl>
          <dt><code><b>set_near_reach</b> &lt;reach_name&gt;</code></dt>
          <dd>Makes it use the specified reach as the "near reach", from here on out.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_sector_scroll</code></th>
        <td><dl>
          <dt><code><b>set_sector_scroll</b> &lt;x_speed&gt; &lt;y_speed&gt;</code></dt>
          <dd>Makes the sector this object is on begin scrolling, with the specified speed in the X axis (units per second) and the specified speed in the Y axis. Its floor texture will scroll along, and any objects on this sector will be dragged too. Setting both values to 0 will make it stop scrolling, naturally.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_state</code></th>
        <td><dl>
          <dt><code><b>set_state</b> &lt;state&gt;</code></dt>
          <dd>Instantly changes to the specified state. If it was meant to run any actions after this one, they will not be run.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_tangible</code></th>
        <td><dl>
          <dt><code><b>set_tangible</b> &lt;true/false&gt;</code></dt>
          <dd>Sets whether or not this mob can be touched by others. This only affects whether or not the mob can push or be pushed.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_team</code></th>
        <td><dl>
          <dt><code><b>set_team</b> &lt;team_name&gt;</code></dt>
          <dd>
            Sets the object's current team. Objects in the same team will not hunt or harm each other. Valid values are:
            <ul>
              <li><b><code>none</code></b>: Does not belong to a team.</li>
              <li><b><code>player_X</code></b>: Belongs to player 1, 2, 3, or 4's team (replace the X with a number). Usually used for leaders and Pikmin.</li>
              <li><b><code>enemy_X</code></b>: Belongs to the enemy team 1, 2, 3, or 4 (replace the X with a number).</li>
              <li><b><code>obstacle</code></b>: Obstacle team.</li>
              <li><b><code>other</code></b>: Team for whatever else.</li>
            </ul>
          </dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_timer</code></th>
        <td><dl>
          <dt><code><b>set_timer</b> &lt;amount&gt;</code></dt>
          <dd>Starts the mob's timer with the specified time period. Writing 0 makes the current timer stop, without triggering any <code>on_timer</code> events.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>set_var</code></th>
        <td><dl>
          <dt><code><b>set_var</b> &lt;variable&gt; &lt;value&gt;</code></dt>
          <dd>Sets the value of the specified variable.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>show_message_from_var</code></th>
        <td><dl>
          <dt><code><b>show_message_from_var</b> &lt;variable&gt;</code></dt>
          <dd>Shows a message on-screen using the text inside the specific variable. Any <code>\n</code> in that text represents a line break.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>spawn</code></th>
        <td><dl>
          <dt><code><b>spawn</b> &lt;spawn data&gt;</code></dt>
          <dd>Instantly creates a new object, with the information in the supplied spawn data block. See <a href="mob_type.html#spawning">here</a> for more information.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>stabilize_z</code></th>
        <td><dl>
          <dt><code><b>stabilize_z</b> &lt;reference&gt; &lt;offset&gt;</code></dt>
          <dd>Changes the object's Z coordinate to match the Z coordinate of its highest (if the reference is <code>highest</code>) or lowest (if the reference is <code>lowest</code>) linked object. After changing it, it also moves it up by the specified offset.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>start_chomping</code></th>
        <td>
          Sets what body parts will be used to trap Pikmin from here on out.
          <dl><dt><code><b>start_chomping</b> &lt;victim_max&gt; &lt;body_parts&gt;</code></dt>
          <dd>&lt;victim_max&gt; is the maximum number of Pikmin that can be caught. &lt;body_parts&gt; is the name of the body part(s) that will be used for trapping, one per word.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>start_dying</code></th>
        <td>Runs the procedure related to the start of the object's death sequence. Amongst other things, this makes enemies unleash a cloud of sparkle particles.</td>
      </tr>
      <tr>
        <th><code>start_height_effect</code></th>
        <td>Records the object's current Z and, from here on out, scales the object larger the higher it is from that pivot Z. This creates a fake perspective effect that reflects how high the object is. This feature cannot scale any smaller than normal size. Use <code>stop_height_effect</code> to return to normal.</td>
      </tr>
      <tr>
        <th><code>start_particles</code></th>
        <td><dl>
          <dt><code><b>start_particles</b> &lt;generator_name&gt; [&lt;x offset&gt;] [&lt;y offset&gt;] [&lt;z offset&gt;]</code></dt>
          <dd>Begin emitting particles using the specified particle generator. If specified, the x, y, and z coordinates are the offset from the object's center coordinates and Z coordinate, based on the object's angle. See <a href="#rel-coord">here</a> for more info. If the particle generator specified has no interval (i.e. it only launches particles once and then it's over), then the particle generator is automatically removed from the object after it emits its particles. An object can only have one script-given particle generator attached at a time.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>stop</code></th>
        <td>Makes the object stop moving laterally, and makes it stop rotating.</td>
      </tr>
      <tr>
        <th><code>stop_vertically</code></th>
        <td>Kills the object's vertical momentum.</td>
      </tr>
      <tr>
        <th><code>stop_chomping</code></th>
        <td>Makes it so no body parts will be used for chomping any more, from here on out.</td>
      </tr>
      <tr>
        <th><code>stop_height_effect</code></th>
        <td>Stops the height effect started with <code>start_height_effect</code>. This also gets called every time the object touches the floor.</td>
      </tr>
      <tr>
        <th><code>stop_particles</code></th>
        <td>Removes any currently attached particle generator.</td>
      </tr>
      <tr>
        <th><code>swallow</code></th>
        <td><dl>
          <dt><code><b>swallow</b> &lt;number&gt;</code></dt>
          <dd>Makes the object swallow &lt;number&gt; amount out of the captured Pikmin, picked at random. This kills the Pikmin.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>swallow_all</code></th>
        <td>Makes the object swallow all captured Pikmin. This kills the Pikmin.</td>
      </tr>
      <tr>
        <th><code>teleport_to_absolute</code></th>
        <td><dl>
          <dt><code><b>teleport_to_absolute</b> &lt;x&gt; &lt;y&gt; &lt;z&gt;</code></dt>
          <dd>Instantly teleports the object to the specified area coordinates.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>teleport_to_relative</code></th>
        <td><dl>
          <dt><code><b>teleport_to_relative</b> &lt;x&gt; &lt;y&gt; &lt;z&gt;</code></dt>
          <dd>Instantly teleports the object to the specified coordinates relative to its position and angle. See <a href="rel-coords">here</a> for more info.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>turn_to_absolute</code></th>
        <td><dl>
          <dt><code><b>turn_to_absolute</b> &lt;angle&gt;</code></dt>
          <dd>Turn towards the specified angle. 0 is east, 90 is south, etc.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>turn_to_relative</code></th>
        <td><dl>
          <dt><code><b>turn_to_relative</b> &lt;angle&gt;</code></dt>
          <dd>Turn &lt;angle&gt; degrees anti-clockwise.</dd>
        </dl></td>
      </tr>
      <tr>
        <th><code>turn_to_target</code></th>
        <td><dl>
          <dt><code><b>turn_to_target</b> &lt;target&gt;</code></dt>
          <dd>
            Turns towards a special target. Possible values are:
            <ul>
              <li><code>arachnorb_head_logic</code>: Used by <a href="https://www.pikminwiki.com/Arachnorb_family">arachnorb</a> head objects to turn according to where their feet objects are located. See the <code>arachnorb_plan_logic</code> action for more information.</li>
              <li><code>focused_mob</code>: Constantly turn towards the focused mob. You can make it stop with the <code>stop</code> action.</li>
              <li><code>home</code>: Turn towards home (spawn point).</li>
            </ul>
          </dd>
        </dl></td>
      </tr>
    </table>

    <h3 id="rel-coord">Relative coordinates</h3>
    
    <p>Some mob actions allow you to specify some coordinates relative to the object. While the absolute coordinates "50,100" are in the location of the map at X=50, Y=100, the relative coordinates "50,100" mean that this is at the object's position, plus 50 to the right, and 100 down. This is assuming the object is facing the right.</p>

    <p>If it isn't, the coordinates rotate around the object, such that a positive X is always in front of the mob. So for coordinates "50,100", this would mean 50 units in front of the mob, and 100 units to its right-hand side.</p>

    <p>The same also applies to relative and absolute angles: a relative angle of 0 means the same angle that the mob is facing, but an absolute angle of 0 means east.</p>

    <h2 id="precautions">Precautions</h2>
    
    <ul>
      <li>When you want to change states, make sure that the action that switches the state is the last one that will be run on the event's code. This is because when a state change action happens, it skips over all other actions that were written after it.</li>
      <li>When changing a state, make sure that the new state's <code>on_enter</code> event doesn't change to another state in a way that could create an infinite loop. For instance, if changing to state A causes it to change to state B, which causes it to change to state C, which causes it to change to state A again, the engine will crash.</li>
    </ul>
    
  </div>
</body>

</html>
