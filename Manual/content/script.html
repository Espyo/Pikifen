<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  <title>Pikifen manual</title>
  <meta name="description" content="The Pikifen user manual">
  
  <link rel="stylesheet" href="../data/style.css">
  <script src="../data/script.js"></script>
</head>

<body onload="setup('Object script', ['Making content'], ['making.html']);">
  <div id="content">
    
    <p>This page will explain how object scripts work in <i>Pikifen</i>, and how you can make your own. If you're in a hurry, feel free to read just the lines in bold, and even skip to the section you need. Otherwise, read every step in the tutorial and follow along! Feel also free to copy and paste an existing enemy's scripts and properties and adjust them to your liking, instead of creating everything from scratch.</p>

    <h2 id="intro">Introduction</h2>
    
    <h3 id="concepts">Key concepts</h3>
    
    <dl>
      <dt><b>Scripts tell an object what to do, and when.</b></dt>
      <dd>Scripts are how you tell an object, like an enemy, what it should do given different scenarios. Like "<i>When</i> a Pikmin shows up, <i>you move</i> to it. <i>When</i> the Pikmin is close, <i>you lunge</i> in for a bite." You can almost think of them like movie or theater scripts: "<i>When</i> the bad guy says 'I'll get you', <i>you say</i> 'never!'. <i>When</i> the bad guy throws the punch, <i>you dodge</i> to the side."</dd>
      <dt><b>An action is an instruction you want the object to do.</b></dt>
      <dd>In <i>Pikifen</i>, an object can perform a wide variety of actions, like moving somewhere, focusing its sights on another object, changing its animation, etc.</dd>
      <dt><b>An event refers to the moment something in the game happens, and you will want the object to perform actions.</b></dt>
      <dd>Events are the "when"s in the analogy above. An event can be something like when a Pikmin approaches, when the object reaches its intended destination, when its current animation finishes, etc. So, in essence when an <i>event</i> happens, the object will perform some <i>actions</i>.</dd>
      <dt><b>Objects can be in one of several states. Depending on the state, the same event can perform different actions.</b></dt>
      <dd>You can think of a state like a state of mind: tired, hungry, bored, etc. For object like enemies it's more along the lines of returning home, chasing prey, looking around, etc. States are important, because depending on the state, we may want the same event to trigger different actions. For instance, suppose a Pikmin comes near. What is a Red Bulborb to do? Well, it depends on its state: if it's sleeping, it must wake up, but if it is awake, it should lunge in for a chomp. Events and actions must take place inside of a state.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>"Mob" (short for "mobile object") is an alternate name for "object".</li>
      </ul></dd>
    </dl>

    <h2 id="guide">Guide</h2>
    
    <h3 id="creating">Creating the script</h3>
    
    <p>For this tutorial, we'll be writing the script for a Red Bulborb with some tweaks. If you haven't already, follow the <a href="mob_type.html">object type tutorial</a> to create this new enemy.</p>
    
    <dl>
      <dt><b>Start by creating <code>Script.txt</code> in the object's data folder.</b></dt>
      <dd>Go to the folder where the object's data is, and create a new <a href="making.html#data-file">data file</a> called <code>Script.txt</code>.</dd>
      <dt><b>Inside, write a block called <code>script</code>.</b></dt>
      <dd>Inside the data file, write a line with <code>script {</code>. As explained <a href="making.html#data-file">here</a>, this is the start of a block. The next line should just be <code>}</code>, and now any line between these two is data inside the <code>script</code> block &ndash; the Red Bulborb's script in our case.</dd>
    </dl>

    <h3 id="state">Making a state</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        
    }
}
</pre>
    </div>
    
    <p>We'll need to start the script with a state. Let's think of the most "normal" state for a Bulborb, to serve as a starting point. That would probably be the sleeping state, right? Most Bulborbs we see in the games are asleep when first met, so it makes sense to start here.</p>
    
    <dl>
      <dt><b>Every block inside of the <code>script</code> block is a state.</b></dt>
      <dd>Let's start by creating a block called <code>sleeping</code> inside of the <code>script</code> block. Inside this block is where we'll specify what events and actions can take place while in this state.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>State names cannot have spaces in them.</li>
      </ul></dd>
    </dl>

    <h3 id="event">Looking out for an event</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        on_touch_opponent {
            
        }
    }
}
</pre>
    </div>

    <p>Now let's see, in this state, there's not much the Bulborb can do except wake up. Let's make it so that it wakes up when a Pikmin or leader touches it.</p>
    
    <dl>
      <dt><b>There is a specific list of available events, and they all start with <code>on_</code>.</b></dt>
      <dd>The events are moments in time where specific things happen, specific things that the engine recognizes. Their names all start with <code>on_</code>, as in "<i>on</i> the event that <i>this</i> happens, do <i>that</i>". The full list can be found <a href="events_and_actions.html">here</a>.</dd>
      <dt><b>Some events are related to "opponents" &ndash; these are objects that our object can hunt down.</b></dt>
      <dd>For an enemy, Pikmin and leaders are considered "opponents". This means that the event "when an opponent touches" will be triggered every time a Pikmin or a leader touches our Bulborb. Depending on the object's data, different types of objects can or cannot be considered "opponents".</dd>
      <dt><b>Each block inside a state's block represents an event.</b></dt>
      <dd>To add the "when an opponent touches" event, write a block called <code>on_touch_opponent</code>. Inside is where we'll write what actions the Bulborb should take.</dd>
    </dl>

    <h3 id="action">Performing an action</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        on_touch_opponent {
            set_animation waking_up
            set_state waking_up
        }
    }
    
    waking_up {
        
    }
}
</pre>
    </div>

    <p>Let's assume that you already have animations for the Bulborb &ndash; these include waking up, walking, biting, going back to sleep, etc. What we want now is for the Bulborb to wake up. Visually, we want its animation to change from the one where it is sleeping to the one where it wakes up and gets on its feet.</p>
    
    <dl>
      <dt><b>Like events, there is a specific list of available actions.</b></dt>
      <dd>Actions are what our object can do, and these too are specific things that the engine is capable of making an object do. The full list can be found <a href="events_and_actions.html">here</a>.</dd>
      <dt><b>Inside the event's block, write one action per line.</b></dt>
      <dd>We can run multiple actions in a row in an event, and each action should be written in its own line inside the event block. To set the Bulborb's animation to waking up, begin by writing <code>set_animation</code>.</dd>
      <dt><b>Most actions take arguments. These come after the action name and are separated by spaces.</b></dt>
      <dd>The <code>set_animation</code> action needs to know what animation to switch to, so write a space after <code>set_animation</code>, and then <code>waking_up</code>. In the Red Bulborb's animations, this is the name of the animation that makes it become awake and stand up, but when making your own objects, you can use whatever names you wish.</dd>
      <dt><b>Changing states in key in order to organize what events you want to handle.</b></dt>
      <dd>So, when the Bulborb is in the sleeping <i>state</i>, in the <i>event</i> that an opponent touches it, it will perform an <i>action</i> in which it changes its animation to waking up. Makes sense, but...when a Pikmin touches it, the Bulborb will visually change to an animation where it wakes up, and then what? Well, right after the Bulborb begins this animation, the engine will realize the next frame that an opponent is touching it (yet still). And because the Red Bulborb is still in the "sleeping" state, which is a state that is looking out for the "opponent is touching" event...it will just trigger the event again and again, which will keep restarting the animation (until the Pikmin walks away at least). The logical solution would be to change its state right after setting its animation, so that it may wake up in peace, without being interrupted by the constant "opponent is touching" events. As such, add a new action: <code>set_state waking_up</code>. As you can guess, this will make the Red Bulborb change to a <code>waking_up</code> state after starting the wake up animation. Might as well add the new state too; add an empty line between them to help with readability.</dd>
    </dl>
    
    <h3 id="on-enter">On enter</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    sleeping {
        on_enter {
            set_animation sleeping
        }
        on_touch_opponent {
            set_state waking_up
        }
    }
    
    waking_up {
        on_enter {
            set_animation waking_up
        }
    }
}
</pre>
    </div>

    <dl>
      <dt><b>If you're running actions before changing a state, consider running those actions inside the state's <code>on_enter</code> event.</b></dt>
      <dd>When we set its animation to waking up, we're also set its state to "waking_up". Imagine we wanted the Bulborb to wake up for a reason other than an opponent touching it, like due to a timer or a nearby loud sound. It would be a pain to write an action to change animations alongside the action to change states. So instead, create an event in the "waking_up" state called <code>on_enter</code> and change the animation there &ndash; this event is run every time the state is entered, so no matter what made it go to the "waking_up" state, its animation will always be set appropriately!</dd>
      <dt><b>It's a good idea in general to use <code>on_enter</code> in order to let states be responsible for the actions related to them.</b></dt>
      <dd>Your script becomes much easier to understand if the reader can understand that "every time the Bulborb is waking up, its animation will always change accordingly". Plus, it's less repeated text anyway. There is also something to note with the Red Bulborb right now: it actually has no starting animation! The script has to tell it what animation to change to when it spawns. Since we want it to spawn in the "sleeping" state, and since every time the sleeping state is entered, the creature is meant to visually fall asleep, it makes sense to change its animation to "sleeping" in the "sleeping" state's <code>on_enter</code> event.</dd>
    </dl>
    
    <h3 id="on-anim-end">On animation end</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    waking_up {
        on_enter {
            set_animation waking_up
        }
        on_animation_end {
            set_state examining
        }
    }
}
</pre>
    </div>

    <p>Ok, now that the Red Bulborb can enter the "waking up" animation, what should it do while in it? Well, it shouldn't really be willing to fight, should it? It <i>is</i> still getting up, so it's not ready for that. In fact, it should do anything while in this state except finish getting up. As soon as it finishes though, it should probably look around for whatever woke it up.</p>
    
    <dl>
      <dt><b><code>on_animation_end</code> is a powerful tool for pacing.</b></dt>
      <dd>If you want the object to perform an action when it <i>finishes</i> doing something, and that something is behind an animation, just use the <code>on_animation_end</code> event. The alternative would be to wait for a set amount of time, but that's harder to do, and requires you to update the timer if you change the animation's length. As for what actions to get our Red Bulborb to perform, it would make sense to enter a state where it analyzes its surroundings and acts according to what it decides at the time (going back to sleep, chasing prey, etc.).</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>Because animations loop, this event gets triggered every time the final frame is finished (which is also when the animation returns to the loop frame).</li>
      </ul></dd>
    </dl>

    <h3 id="moving">Moving</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    examining {
        on_enter {
            set_animation examining
        }
        on_animation_end {
            set_state returning
        }
    }
    
    returning {
        on_enter {
            move_to_target home
        }
        on_reach_destination {
            set_state sleeping
        }
    }
}
</pre>
    </div>

    <p>In the "examining" state, we can set its animation to make it look around left and right in search of what prey to catch. Later on, we'll make it detect Pikmin nearby, but for now, if nothing catches its interest by the time it finishes its animation, it should head back home (the spawn point) and fall asleep. You might find it weird why the Bulborb would try to go home right after waking up, but remember that we can use the "examining" state elsewhere too, like after it finished eating all Pikmin, or has wandered too far.</p>
    
    <dl>
      <dt><b><code>move_to_target</code> tells an object to <i>start</i> moving towards a specific target.</b></dt>
      <dd>As soon as the <code>move_to_target</code> action is run, the object will start moving to where you specify, and will keep moving over time from there on, until it is told to stop or move elsewhere.</dd>
      <dt><b><code>move_to_target</code> takes a specific target as an argument, and other actions allow other types of movement.</b></dt>
      <dd>In order for the engine to know where to make the object move to, you have to write it as an argument for the action. Since we want the Red Bulborb to head home, write <code>home</code> as the argument &ndash; the engine recognizes this as a special word that means it should head towards the spawn coordinates.</dd>
      <dt><b>When it reaches its destination, <code>on_reach_destination</code> is triggered.</b></dt>
      <dd>For our Red Bulborb, when it reaches its destination &ndash; home &ndash; we can make it enter the state where it falls asleep.</dd>
    </dl>

    <h3 id="reach">Reach and chasing</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    examining {
        on_enter {
            set_animation examining
            set_near_reach search
            set_far_reach chase
        }
        on_opponent_in_reach {
            focus trigger
            set_state chasing
        }
        on_animation_end {
            set_state returning
        }
    }
    <span class="code-faded">(...)</span>
    chasing {
        on_enter {
            move_to_target focused_mob
        }
        on_focus_off_reach {
            set_state examining
        }
    }
}
</pre>
    </div>

    <p>What about moving towards a Pikmin? In the examining state, in the event that it spots a Pikmin, it should move towards it to try to eat it, right? But let's think about what it means to "spot a Pikmin".</p>
    
    <dl>
      <dt><b>An object considers another object to be "near" if it is within a certain reach.</b></dt>
      <dd>We want our Red Bulborb to detect Pikmin that it can reasonably see. If a Pikmin is within vision reach of the Bulborb, then the <code>on_opponent_in_reach</code> event will be triggered.</dd>
      <dt><b>Objects can have several "reaches", and different objectives require using different reaches.</b></dt>
      <dd>To notice a Pikmin, we can use a reach that's a good distance away, since the bug-eyed Bulborb can see fairly far. However, if the creature is giving chase, then the concept of "near" for the purposes of eating a Pikmin changes &ndash; it's no longer about the reach of its eyesight, but the reach of its lunge attack. At any moment in the script, you can swap out what constitutes as "near" using the <code>set_near_reach</code> action. When the Bulborb starts examining, i.e., when the "examining" state is entered, we want "near" to be considered its searching reach. So, type <code>set_near_reach search</code> as the action. We'll define this "search" reach's information <a href="#script-props">later on in the tutorial</a>.</dd>
      <dt><b>An object can be focused onto another object, until told otherwise.</b></dt>
      <dd>When the Red Bulborb notices its prey, i.e., when <code>on_opponent_in_reach</code> is triggered, we want the Bulborb to start moving towards the Pikmin. But the Pikmin will surely change position over time, so we can't just tell the Bulborb to move to the coordinates where the Pikmin is at the moment. In order to keep track of the enemy over time, we need to say that the Bulborb will take focus on the Pikmin. Then we can just order the Bulborb to chase after its focused object, and it will be able to keep up with the Pikmin as it moves.</dd>
      <dt><b>To choose what to focus on, the <code>focus</code> action can take an argument. <code>trigger</code> means it will focus on whatever triggered the event.</b></dt>
      <dd>How do we specify that we want the Bulborb to focus on the Pikmin that is near? Well, since when an opponent is near, the <code>on_opponent_in_reach</code> gets triggered, we can just tell the engine to focus on whatever object triggered the event. Add the action <code>focus trigger</code> to the <code>on_opponent_in_reach</code> event to do just that. This will make the Bulborb focus on the Pikmin in question.</dd>
      <dt><b>Use <code>move_to_target focused_mob</code> to get an object to constantly move towards its focus.</b></dt>
      <dd>After it focuses on the opponent found, it should change to a state where it's giving chase. In this state, add an action to move after said opponent: <code>move_to_target focused_mob</code>.</dd>
      <dt><b>Use reaches to detect if the focused object is "out of reach", with the action <code>set_far_reach</code> and event <code>on_focus_off_reach</code>.</b></dt>
      <dd>We will want the Bulborb's vision limit to allow it to lose track of its prey as well. When you set the "near" reach, you should also set the "far" reach, using the action <code>set_far_reach chase</code>; "chase" is another reach we'll define later. When the focused object is out of reach, the <code>on_focus_off_reach</code> event is triggered. This helpfully also gets triggered if the Pikmin becomes unavailable, like if it dies. So, let's add an action to return to the examining state in this event.</dd>
    </dl>

    <h3 id="attacking">Attacking</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
script {
    <span class="code-faded">(...)</span>
    chasing {
        on_enter {
            move_to_target focused_mob
            set_near_reach attack
        }
        on_opponent_in_reach {
            set_state attacking
        }
        on_focus_off_reach {
            set_state examining
        }
    }
    
    attacking {
        on_enter {
            set_animation attacking
            start_chomping 3 mouth
        }
        on_animation_end {
            stop_chomping
            set_state eating
        }
    }
    
    eating {
        on_enter {
            set_animation eating
        }
        on_animation_end {
            swallow_all
        }
    }
}
</pre>
    </div>

    <p>In the "chasing" state, our Bulborb is in pursuit. It's got its sights locked on to the Pikmin, and is always moving in its direction. On the event that it gets near (remember to update the "reach"!), it should go for a bite.</p>
    
    <dl>
      <dt><b>Biting works by having the enemy's "mouth" capable of capturing Pikmin. This mouth is usually located wherever the "mouth" body part is.</b></dt>
      <dd>The general way biting works in the <i>Pikmin</i> games is that an enemy clamps its jaws in front of it, and any Pikmin that get hit will be caught in its mouth. In order for the whole "catching" part to work, we need to keep in mind something about animations; read the <a href="animation.html">animation tutorial</a> if you need a reminder. Each object has a set of body parts, and they are named. Enemies like a Red Bulborb should have a "mouth" body part, because this is the body part that will be keeping hold of any captured Pikmin. Though "mouth" is the standard, you can have any body parts in charge of chomping, like a tongue, or several proboscises.</dd>
      <dt><b>A body part can start chomping with the <code>start_chomping</code> action.</b></dt>
      <dd>When the Bulborb begins lunging, its mouth is no longer a passive body part sitting around doing nothing. The creature will open its mouth and will use it to capture Pikmin. So, in the beginning of its lunging procedure (i.e. when the Bulborb enters the "lunging" state), we should let the engine know that its "mouth" body part is now a Pikmin-eating body part by using the <code>start_chomping</code> action.</dd>
      <dt><b><code>start_chomping</code> takes the maximum capture limit and hitbox list as parameters.</b></dt>
      <dd>In the <i>Pikmin</i> games, if a bunch of Pikmin get hit by a Red Bulborb's bite, only 3 or 5 (depends on the game) will actually get caught. You can specify such a limit in the engine too. For our cases, let's go with <code>start_chomping 3 mouth</code>. In this action, <code>mouth</code> is the name of the body part that will be responsible for capturing Pikmin from here on, but if we had more, we could've added them afterwards, one per word.</dd>
      <dt><b>Remember to stop the chomping process at some point!</b></dt>
      <dd>When the lunge animation is over, you should set the "mouth" body part back to normal, so Pikmin don't accidentally get caught later when the enemy is, for instance, walking. To do this, write <code>stop_chomping</code>.</dd>
      <dt><b>An enemy can swallow the captured Pikmin with <code>swallow_all</code></b></dt>
      <dd>For our Red Bulborb, after the animation is over, we want it to enter a "chewing" state, and when that's finished, swallow all captured Pikmin. This is achieved with the action <code>swallow_all</code>. Other actions exist to swallow only some, or to release them all.</dd>
    </dl>

    <h3 id="vars">Variables</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
init {
    set_var pim 0
}

script {
    <span class="code-faded">(...)</span>
    attacking {
        on_enter {
            set_animation attacking
            start_chomping 3 mouth
        }
        on_animation_end {
            stop_chomping
            get_mob_info pim self chomped_pikmin
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
    </div>

    <p>The Red Bulborb lunges. But did it capture any Pikmin? We actually need to know this in order to decide if the creature should start chomping, or if it should flop to the ground.</p>
    
    <dl>
      <dt><b>You can ask the engine for information about an object using the <code>get_mob_info</code> action.</b></dt>
      <dd>When the attack animation ends, we want to know how many Pikmin the Red Bulborb has chomped, so let's ask with <code>get_mob_info pim self chomped_pikmin</code>. Here, <code>chomped_pikmin</code> is a special word that means we want to know, well, how many Pikmin are chomped.</dd>
      <dt><b>Information, like the answer to the <code>get_mob_info</code> questions, is saved in a variable.</b></dt>
      <dd>In the action you wrote, <code>pim</code> is the name of a variable (or "var"). This is some place in the object's memory that will hold information for us. Its name can be whatever, but in this tutorial, let's go with "pim", which is short for "Pikmin in mouth". After that action is run, the number of Pikmin chomped will reside inside the "pim" variable in the object's memory, from here on. You can have as many variables as you want.</dd>
      <dt><b>The value inside of a variable can be accessed in an action by writing the variable's name after a dollar sign.</b></dt>
      <dd>After the "pim" variable received a value, we can get that value and make use of it in the script, simply by typing <code>$pim</code>. When the script is run, it will replace that <code>$pim</code> with 0, or 1, or whatever else the "pim" variable is worth at the time.</dd>
      <dt><b>It's good practice to declare a starting value for your variables.</b></dt>
      <dd>For this, you can create an <code>init</code> block <i>outside</i> of the <code>script</code> block, and in it, add <code>set_var pim 0</code>. This will set the value of the "pim" variable to 0. Any actions inside this block will be run when the object is created, so you always know what the starting value of every variable is.</dd>
      <dt><b>Specific objects can also spawn with specific values in specific variables. Use this to allow different objects in the area to act differently.</b></dt>
      <dd>Any specific object in the area can spawn with some new variables set, or some initial variables altered from the norm. For instance, an Armored Cannon Beetle can spawn a boulder and tell it to be homing, or in the area editor, you can tell one specific Pellet Posy to start already bloomed. This data is stored in the script variables, and parts of the script can make use of them to change the object's behavior. Or if a given variable is not set, the script can use the default value specified in the aforementioned <code>init</code> block. You can use this to allow different objects to behave differently using the same script.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>The engine can make use of the script variable system to allow you to set some internal data about the object, like a Pikmin's starting maturity, or an object's team. You don't need to do anything with this information, but it is helpful to know this is how the engine works.</li>
      </ul></dd>
    </dl>

    <h3 id="conditions">Conditions</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
<span class="code-faded">(...)</span>
script {
    <span class="code-faded">(...)</span>
    attacking {
        on_enter {
            set_animation attacking
            start_chomping 3 mouth
        }
        on_animation_end {
            stop_chomping
            get_mob_info pim self chomped_pikmin
            if $pim > 0
                set_state eating
            else
                set_state flopping
            end_if
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
    </div>

    <p>Now to actually decide what to do after the lunge. The creature's behavior splits into two here: <i>if</i> it caught something, it should change to a chomping state, <i>else</i>, it should flop to the ground. This conditional logic can be written in the script.</p>
    
    <dl>
      <dt><b>You can choose what the next actions should be with an <code>if</code> action.</b></dt>
      <dd>After knowing how many Pikmin got bit, let's run an <code>if</code> action. Write it down as such: <code>if $pim > 0</code>. This action, when run, will check the number of Pikmin in its mouth, via our "pim" variable. Naturally, in this case, we want to check if more than zero Pikmin got caught. Then this action will change the flow of the script: if the Bulborb caught Pikmin, the script continues on to the next actions. So after this <code>if</code> action, add the action to enter a chewing state. Although in this case we're just checking if a number is larger than another, the <code>if</code> action can do other comparisons.</dd>
      <dt><b>If the condition is true, the script will run what comes next. Otherwise, it will jump to the matching <code>else</code> action.</b></dt>
      <dd>But what if the Bulborb didn't capture anything? Well, write an <code>else</code> action after the action that sets to the chewing state. And after that, write the action to change to a flopping state. With all of this logic combined, the engine will enter that <code>if</code> action, and if it realizes the condition is false (i.e. no Pikmin got chomped), it will jump to the actions after the "else".</dd>
      <dt><b>Finish your conditional logic with <code>end_if</code></b>.</dt>
      <dd>To wrap up the conditional part of this event, after the action that changes to the flopping state, you will need to add an <code>end_if</code> action. With this, the engine knows that what comes after is no longer a part of the conditional logic, and its flow works like normal.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>You don't always need to add an "else" part to your condition.</li>
        <li>You may want to indent (add another tab at the start) lines inside the "if" and "else" parts. This tutorial's logic is simple, but more complex conditions and flows will be much easier to read if you can easily tell what belongs to what part of the condition, just from the way the text is laid out.</li>
      </ul></dd>
    </dl>

    <h3 id="death">Death</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
death_state = dying
<span class="code-faded">(...)</span>
script {
    <span class="code-faded">(...)</span>
    dying {
        on_enter {
            start_dying
            set_animation dying
        }
        on_animation_end {
            finish_dying
        }
    }
}
</pre>
    </div>

    <dl>
      <dt><b>When an object reaches 0 health, the script automatically jumps to a death state.</b></dt>
      <dd>The enemy can die at (almost) any moment. When that happens, the engine automatically jumps the script into a different state, so you don't need to worry about listening to the death event on every single state.</dd>
      <dt><b>The name of this state is specified in the <code>death_state</code> property outside the script.</b></dt>
      <dd>To specify what state it should jump into, go out of the <code>script</code> block, and write a line with <code>death_state = dying</code>. This way, the engine knows that when the enemy's HP reaches 0, it must enter the "dying" state. Be sure to also write this new state.</dd>
      <dt><b>There are two usually parts to an enemy's death: the start and the end.</b></dt>
      <dd>When an enemy's HP reaches 0, you likely want to make them perform a fainting animation, as well as call a special action that will run some extra code related to an enemy beginning to die (this code will, amongst other things, create the sparkling particles). This is done with the action <code>start_dying</code>. When it's time to register the enemy as completely dead (like when the fainting animation ends), you need to call the action <code>finish_dying</code>. This will make the object carriable, release a spirit, etc.</dd>
    </dl>

    <h3 id="timers">Timers</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
<span class="code-faded">(...)</span>
script {
    sleeping {
        on_enter {
            set_animation sleeping
            set_timer 20
        }
        on_touch_opponent {
            set_state waking_up
        }
        on_timer {
            set_state waking_up
        }
    }
    
    waking_up {
        on_enter {
            set_animation waking_up
            set_timer 0
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
    </div>

    <p>Remember earlier when the idea of having the Bulborb wake up due to a biological timer came up? Let's implement that. Let's say that every time the Bulborb falls asleep, its biological clock sets an alarm for 20 seconds, at which point, it will wake up on its own, look around, and if there's nothing going on, fall asleep again.</p>
    
    <dl>
      <dt><b>Start the timer with <code>set_timer</code>.</b></dt>
      <dd>When the Bulborb falls asleep, so when the "sleeping" state is entered, use the following action: <code>set_timer 20</code>. This will start an internal timer for the object that will tick in 20 seconds.</dd>
      <dt><b>When the timer reaches 0, the <code>on_timer</code> event is triggered.</b></dt>
      <dd>In the sleeping state, look out for the <code>on_timer</code> event. This will be triggered when the timer reaches 0. This would be the time to change the state to the "waking_up" state.</dd>
      <dt><b>If the timer is running, <code>set_timer 0</code> will deactivate it.</b></dt>
      <dd>What if the Red Bulborb's sleep is interrupted by a leader or Pikmin walking near? The timer would keep going, which is something we likely don't want. You can kill the timer by simply typing <code>set_timer 0</code>.</dd>
      <dt><b>Notes:</b></dt>
      <dd><ul>
        <li>An object can only have one active timer at any moment.</li>
        <li>When a timer reaches 0, it deactivates, so if you have a timer that you want to tick every X seconds, you need to set the timer again when it reaches zero.</li>
      </ul></dd>
    </dl>
    
    <h3 id="script-props">Script-related properties</h3>
    
    <div class="box box-right">
      <p>After this section, your script should look like:</p>
<pre>
first_state = sleeping
<span class="code-faded">(...)</span>
script {
    <span class="code-faded">(...)</span>
    chasing {
        on_enter {
            move_to_target focused_mob
            set_near_reach attack
        }
        on_opponent_in_reach {
            set_state attacking
        }
        on_focus_off_reach {
            set_state examining
        }
        on_far_from_home {
            set_state returning
        }
    }
    <span class="code-faded">(...)</span>
}
</pre>
      <p>And the data file should look like:</p>
<pre>
<span class="code-faded">(...)</span>
itch_damage = 70
itch_time = 5
territory_radius = 500
reaches {
    wake_up = 10 360
    search = 250 180 30 360
    attack = 40 30
    chase = 250 360
}
</pre>
    </div>

    <p>In order for the engine to get a grip on this script, we'll need to specify a few more things. After this section, it's all up to you to finish the Red Bulborb however you like!</p>
    
    <dl>
      <dt><b>The <code>first_state</code> property specifies what the starting state is.</b></dt>
      <dd>Outside of the <code>script</code> block, add the following property outside the <code>script</code> block: <code>first_state = sleeping</code>.</dd>
      <dt><b>Use <code>itch_damage</code> and <code>itch_time</code> to control when an enemy should shake Pikmin off, along with the <code>on_itch</code> event.</b></dt>
      <dd>These two properties go in the enemy's <code>Data.txt</code> file. After an enemy has taken a certain amount of damage, it will be considered "itchy". With this, you can listen to the <code>on_itch</code> event, and make the enemy shake the Pikmin off. Handling this event automatically resets the amount of damage, making it possible for the enemy to be itchy again next time it takes this amount of damage. Setting this to something like 10% or 20% of the max health is usually the way to go. <code>itch_time</code> exists to stop the enemy from shaking too often. Specify a minimum time requirement between itches here, in seconds. 5 is probably good for our Bulborb.</dd>
      <dt><b>Use <code>territory_radius</code> to determine when to trigger <code>on_far_from_home</code>.</b></dt>
      <dd>When the enemy travels too far from its home, the <code>on_far_from_home</code> event is triggered. How far this is is controlled by the <code>territory_radius</code> property, also in <code>Data.txt</code>. You want to put around 500 here for the Red Bulborb.</dd>
      <dt><b>The <code>reaches</code> block in <code>Data.txt</code> contains information about each reach.</b></dt>
      <dd>Remember the reaches from before? This is where you'll define what a "waking up" reach is, what a "chasing" reach is, etc. In <code>Data.txt</code>, create a block called <code>reaches</code>. Inside, we'll write one reach per line.</dd>
      <dt><b>Each reach has a name, a distance, and an angle.</b></dt>
      <dd>Let's start with the <code>wake_up</code> reach, by typing <code>wake_up = 10 360</code>. The <code>10</code> there is the distance &ndash; any Pikmin or leader within 10 units of the Red Bulborb will be considered "in reach". The <code>360</code> is the angle, and because we want this to happen regardless of where the Pikmin is in relation to where the Bulborb is facing, it's a 360 degree range.</dd>
      <dt><b>A reach can also be made of two distance + angle pairs.</b></dt>
      <dd>Now, add <code>search = 250 180 30 360</code> for the next range. The first part means that Pikmin within 180 degrees of the Bulborb's front, and within 250 units, will be considered "in reach". This makes sense: any Pikmin that's within a fair distance in front of the Bulborb should be enough for the enemy to spot it. The second part means that any Pikmin within 30 units, at any angle, will <i>also</i> be considered "in reach". This extra part is useful for when the Pikmin is, for instance, hitting the Bulborb's back. Since the Pikmin is completely behind the Bulborb, it wouldn't be caught by the 250-180 part, since that one only finds Pikmin in front. This way, any Pikmin close enough will also be considered "seen" by the Bulborb. The reason why we don't set the within-250-unit reach to 360 degrees is because that would unrealistically make the Bulborb see Pikmin far away that are <i>behind it</i>. When making enemies yourself, don't be afraid to try some trial-and-error. The Bulborb's other reaches will be something like <code>attack = 40 30</code> (Pikmin within this reach should be chomped), and <code>chase = 250 360</code> (focused Pikmin outside this reach will be considered lost).</dd>
      <dt><b>Use <code>states_ignoring_death</code> to stop an object's scrip from being interrupted by a death.</b></dt>
      <dd>When the object's health reaches 0, the script jumps to a different state, as explained previously. In the <code>states_ignoring_death</code> property of <code>Script.txt</code>, you can list states that are meant to ignore the death event (separated by semicolon). If you find that a death event is being sent on states you don't want, add the state's name here. Similarly, there are the <code>states_ignoring_spray</code> and <code>states_ignoring_hazard</code> properties.</dd>
    </dl>
    
    <h2 id="hardcoded">Hardcoded script</h2>
    
    <dl>
      <dt><b>Some categories of object type do not require you to build a script.</b></dt>
      <dd>Pikmin, leaders, and some other categories all have a hardcoded script inside the engine's logic, and you can create a new Pikmin or leader without worrying about scripting them. This is because these objects require much more complex operations than normal.</dd>
      <dt><b>You cannot edit hardcoded scripts, but you can enhance them.</b></dt>
      <dd>To do so, add a <code>Script.txt</code> file to the object's folder like normal. Now you can write existing states or new ones, and inside, write existing events or new ones. If this is a new state, or a new event in an existing state, the engine will simply run the actions you specify when the time comes. Otherwise, the engine will run your actions first and then run whatever hardcoded actions it is meant to.</dd>
      <dt><b>If the state/event already exists, your actions are run first by default.</b></dt>
      <dd>The reason the engine runs your actions first is because its own logic likely changes the state, and any action that comes after a state change will be ignored. That said, if you want the actions in a given event to take place <i>after</i> the hardcoded actions, write <code>custom_actions_after</code> as the first line in your list of actions.</dd>
      <dt><b>The hardcoded scripts are written in the engine's code in C++, and have access to things the <a href="making.html#data-file">data file</a> scripts do not.</b></dt>
      <dd>To know what states and events an object in a category uses, your best bet is to open the engine's source code, check the <code>.cpp</code> code files inside the <code>source/mob_fsms</code> folder, and try to make sense of them. Keep in mind some states handle events that cannot be recognized in a <code>Script.txt</code> file, so you will be unable to extend those.</dd>
      <dt><b>The logic behind the hardcoded scripts is really complex, so try not to get too creative!</b></dt>
      <dd>Because the engine expects objects to follow their hardcoded script, which usually involves a lot of complex tasks, tampering with the script is risky. For instance, if an object was meant to change to a specific state, and you make it change to another one instead, the engine could later on try to do something with the state it <i>thinks</i> the object should be at, and crash. As such, if you want to enhance a hardcoded script, try sticking to things like adding particles, setting some script variables, sending messages, etc.</dd>
    </dl>
    
    <h2 id="precautions">Precautions</h2>
    
    <ul>
      <li>When you want to change states, make sure that the action that switches the state is the last one that will be run on the event's code. This is because when a state change action happens, it skips over all other actions that were written after it.</li>
      <li>When changing a state, make sure that the new state's <code>on_enter</code> event doesn't change to another state in a way that could create an infinite loop. For instance, if changing to state A causes it to change to state B, which causes it to change to state C, which causes it to change to state A again, the engine will crash.</li>
    </ul>

    <h2 id="tips">Tips</h2>

    <ul>
        <li>The <code>init</code> block of the script file runs right as soon as the object spawns. Directly after that, the object changes to its first state and runs that state's <code>on_enter</code> event. Finally, in the first frame of gameplay after the object's creation, the <code>on_ready</code> event will fire. When you want to run something at the start of the object's life, it's important to pick which of these three points to use.</li>
    </ul>

    <h2 id="see-also">See also</h2>

    <ul>
      <li><a href="events_and_actions.html">List of events and actions</a></li>
    </ul>
    
  </div>
</body>

</html>
